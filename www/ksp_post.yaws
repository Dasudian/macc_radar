<erl>
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%                                                                                                         %
%  This file is created as part of research done by the Multi-Agent Coordination & Control (MACC) group.  %
%                                                                                                         %
%  (C) 2013 Johan Philips, Bart Saint Germain, Jan Van Belle, Paul Valckenaers, macc.radar@gmail.com      %
%                                                                                                         %
%  Department of Mechanical Engineering, Katholieke Universiteit Leuven, Belgium.                         %
%                                                                                                         %
%  You may redistribute this software and/or modify it under either the terms of the GNU Lesser           %
%  General Public License version 2.1 (LGPLv2.1 <http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html>) %
%  or (at your discretion) of the Modified BSD License:                                                   %
%  Redistribution and use in source and binary forms, with or without modification, are permitted         %
%  provided that the following conditions are met:                                                        %
%     1. Redistributions of source code must retain the above copyright notice, this list of              %
%        conditions and the following disclaimer.                                                         %
%     2. Redistributions in binary form must reproduce the above copyright notice, this list of           %
%        conditions and the following disclaimer in the documentation and/or other materials              %
%        provided with the distribution.                                                                  %
%     3. The name of the author may not be used to endorse or promote products derived from               %
%        this software without specific prior written permission.                                         %
%  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,    %
%  BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE     %
%  ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  %
%  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS    %
%  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY        %
%  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR           %
%  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY      %
%  OF SUCH DAMAGE.                                                                                        %
%                                                                                                         %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
-include_lib("modum_core/include/states.hrl").
out(A) ->
	S = case postvar(A,"simulate") of
		undefined -> no_sim;
		_ -> sim
	end,
	Upstream = case postvar(A, "upstream") of
		undefined -> no_upstream;
		_ -> upstream
	end,
	Vehicles = case postvar(A,"nbrVehicles") of
		undefined -> [];
		{ok, ValVehicles} -> [list_to_integer(ValVehicles)];
		TupleVehicles -> [list_to_integer(X) || X <- tuple_to_list(TupleVehicles)]
	end,
	Type = case postvar(A, "type") of
		undefined -> [];
		{ok, ValType} -> [list_to_atom(ValType)];
		TupleType -> [list_to_atom(X) || X <- tuple_to_list(TupleType)]
	end,
	Start = case postvar(A,"start") of
		undefined -> [];
		{ok, ValStart} -> [list_to_integer(ValStart)];
		TupleStart -> [list_to_integer(X) || X <- tuple_to_list(TupleStart)]
	end,
	End = case postvar(A,"end") of
		undefined -> [];
		{ok, ValEnd} -> [list_to_integer(ValEnd)];
		TupleEnd -> [list_to_integer(X) || X <- tuple_to_list(TupleEnd)]
	end,
	Arrival = case postvar(A,"arrival") of
		undefined -> [];
		{ok, ValArrival} -> [list_to_integer(ValArrival)];
		TupleArrival -> [list_to_integer(X) || X <- tuple_to_list(TupleArrival)]
	end,
	{ok, O} = postvar(A,"origin"),
	{ok, D} = postvar(A,"destination"),
	{ok, K} = postvar(A,"k"),
	S == no_sim orelse simulate_traffic(Vehicles, Type, Start, End, Arrival, list_to_atom(O), list_to_atom(D), list_to_integer(K), Upstream),
	{Lengths, Paths} = lists:unzip(modum_proxy:get_k_shortest_path(list_to_atom(O), list_to_atom(D), list_to_integer(K))),
	Ids = lists:flatten(io_lib:format("~p", [paths_to_ids(Paths)])), %  [ atom_to_list(Id) || Id <- Path ] || Path <- Paths ]]
	Routes = lists:flatten(io_lib:format("~p", [paths_to_lat_lon(Paths)])),
	Names = lists:flatten(io_lib:format("~p", [paths_to_names(Paths)])),
	Origin = lists:flatten(io_lib:format("~p", [id_to_lat_lon(list_to_atom(O))])),
	Destination = lists:flatten(io_lib:format("~p", [id_to_lat_lon(list_to_atom(D))])),
	OName = node_holon:get_description(list_to_atom(O)),
	DName = node_holon:get_description(list_to_atom(D)),
	Ls = lists:flatten(io_lib:format("~p", [Lengths])),
	[{ssi,"modum.ssi","%",[]},{ssi,"header.ssi", "%", [{"title", "MECA KU Leuven KSP Result"}]},{ssi,"ksp_post.ssi", "%",[{"paths", base64:encode_to_string(lists:flatten(io_lib:write(Paths)))}, {"names", Names}, {"routes", Routes}, {"lengths", Ls}, {"ids", Ids}, {"k",K}, {"oid", O}, {"did", D}, {"oname", OName}, {"dname", DName},{"origin",Origin},{"destination",Destination}]},{ssi,"footer.ssi", "%", []}].

simulate_traffic([V | Vs], [T | Ts], [S | Ss], [E | Es], [_A | As], O, D, K, no_upstream) ->
	io:format("Simulating ~w vehicles of type ~w and departing from ~w to ~w between ~w and ~w.~n", [V, T, O, D, S, E]),
	core_test:create_vehicles(V,{departure_time, {S,E}}, {O,D,K}, T),
	simulate_traffic(Vs,Ts,Ss,Es,As,O,D,K, no_upstream);
simulate_traffic([V | Vs], [T | Ts], [_S | Ss], [_E | Es], [A | As], O, D, K, upstream) ->
	io:format("Simulating ~w vehicles of type ~w and departing from ~w to ~w with upstream search arrival time ~w.~n", [V, T, O, D, A]),
	core_test:create_vehicles(V, {arrival_time, A}, {O,D,K}, T),
	simulate_traffic(Vs,Ts,Ss,Es,As,O,D,K, upstream);	
simulate_traffic([],[],[],[],[], _O,_D,_K,_) ->
	io:format("Finished initialization of vehicles.~n",[]).
	
id_to_lat_lon(Id) ->
	[{Lat, Lon}] = node_holon:get_coordinates(Id),
	[Lat, Lon].
	
odds(L) -> 
	L2 = lists:zip(lists:seq(1, length(L)), L),
    [A || {Ai, A} <- L2, Ai rem 2 == 1].

evens(L) ->
	L2 = lists:zip(lists:seq(1, length(L)), L),
	[A || {Ai, A} <- L2, Ai rem 2 == 0].

paths_to_ids([P | Paths]) ->
	Links = evens(P),
	Ids = lists:map(fun atom_to_list/1, Links),
	[Ids | paths_to_ids(Paths)];
paths_to_ids([]) ->
	[].
	
paths_to_lat_lon([P | Paths]) ->
	Nodes = odds(P),	
	Route = lists:map(fun id_to_lat_lon/1,Nodes),
	[Route | paths_to_lat_lon(Paths)];
paths_to_lat_lon([]) ->
	[].
	
paths_to_names([P | Paths]) ->
	Links = evens(P),
	Route = lists:map(fun link_holon:get_description/1, Links),
	[Route | paths_to_names(Paths)];
paths_to_names([]) ->
	[].
	
 </erl>